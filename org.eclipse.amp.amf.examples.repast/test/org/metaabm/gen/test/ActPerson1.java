package org.metaabm.gen.test;

import org.apache.commons.collections15.IteratorUtils;
import org.apache.commons.collections15.Predicate;
import org.apache.commons.lang.RandomStringUtils;

import java.lang.Iterable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;

import junit.framework.TestCase;

import repast.context.Context;

import repast.engine.schedule.ScheduledMethod;

import repast.parameter.Parameter;

import repast.query.AndQuery;
import repast.query.Query;
import repast.query.QueryUtils;
import repast.query.space.grid.GridWithin;

import repast.space.grid.Grid;
import repast.space.grid.GridPoint;

import repast.util.ContextUtils;
import repast.util.collections.FilteredIterator;

/**
 * Act Person 1 Java Implementation.
 *
 *
 * Generated by metaabm system: Nov 1, 2007 5:24:24 PM PDT
 */
public class ActPerson1 extends TestCase {

    /**
     * Most recent version.
     */
    private static ActModel model;

    /**
     *
     */
    private int vision = 20;

    /**
     *
     */
    private boolean movingTowardGoal = true;
    private String uniqueID;

    /**
     * Constructs a new Act Person 1.
     */
    public ActPerson1() {
        createUniqueID();
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 0)
    public void moveToNearestGoal() {
        final Context context = ContextUtils.getContext(this);

        final Grid territory = (Grid) context.getProjection("Territory");

        if (isMovingTowardGoal()) {
            Query<Object> identityNearGoalAndIsNearestCopyQuery = null;

            Query<Object> identityNearGoalAndIsNearestCopyQueryFlow =
                new Query<Object>() {
                    public Iterable<Object> query() {
                        return new FilteredIterator<Object>(context.iterator(),
                            new Predicate() {
                                public boolean evaluate(Object object) {
                                    if (object instanceof Area) {
                                        Area goalinArea = (Area) object;
                                        return goalinArea.isNearGoal();
                                    } else {
                                        return false;
                                    }
                                }
                            });

                    }

                    public Iterable<Object> query(Iterable<Object> other) {
                        return new FilteredIterator<Object>(query().iterator(),
                            QueryUtils.createContains(other));
                    }
                };

            identityNearGoalAndIsNearestCopyQuery =
                new Query<Object>() {
                        public Iterable<Object> query() {
                            return Collections.EMPTY_LIST;
                        }

                        public Iterable<Object> query(Iterable<Object> other) {
                            final Comparator identityNearGoalAndIsNearestCopyComp =
                                new Comparator<Object>() {
                                    public int distance(Object source,
                                        Object target) {
                                        GridPoint gs =
                                            territory.getLocation(source);
                                        GridPoint gt =
                                            territory.getLocation(target);
                                        return Math.min(Math.abs(gs.getX() -
                                                gt.getX()),
                                            Math.abs(gs.getY() - gt.getY()));
                                    }

                                    public int compare(Object agent1,
                                        Object agent2) {
                                        return distance(this, agent1) -
                                        distance(this, agent2);
                                    }
                                };
                            final Collection identityNearGoalAndIsNearestCopyList =
                                IteratorUtils.toList(other.iterator());
                            final Collection identityNearGoalAndIsNearestCopyMins =
                                new ArrayList();
                            Object minAgent =
                                Collections.min(identityNearGoalAndIsNearestCopyList,
                                    identityNearGoalAndIsNearestCopyComp);
                            while (minAgent != null) {
                                identityNearGoalAndIsNearestCopyMins.add(minAgent);
                                identityNearGoalAndIsNearestCopyList.remove(minAgent);
                                Object nextAgent =
                                    Collections.min(identityNearGoalAndIsNearestCopyList,
                                        identityNearGoalAndIsNearestCopyComp);
                                if (nextAgent != null &&
                                      identityNearGoalAndIsNearestCopyComp.compare(
                                          minAgent, nextAgent) == 0) {
                                    minAgent = nextAgent;
                                } else {
                                    minAgent = null;
                                }
                            }
                            return identityNearGoalAndIsNearestCopyMins;
                        }
                    };

            identityNearGoalAndIsNearestCopyQuery = new AndQuery<Object>(identityNearGoalAndIsNearestCopyQuery,
                    identityNearGoalAndIsNearestCopyQueryFlow);

            Iterator identityNearGoalAndIsNearestCopyIter =
                identityNearGoalAndIsNearestCopyQuery.query(context.getRandomObjects(
                        Area.class, context.size())).iterator();
            if (identityNearGoalAndIsNearestCopyIter.hasNext()) {
                final Area goalinArea =
                    (Area) identityNearGoalAndIsNearestCopyIter.next();

                int[] aMoveCopyLoc =
                    territory.getLocation(goalinArea).toIntArray(null);
                territory.moveTo(this, aMoveCopyLoc);

            }
        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 3)
    public void multiCriteriaGoal() {
        final Context context = ContextUtils.getContext(this);

        final Grid territory = (Grid) context.getProjection("Territory");

        Query<Object> nearestAnd_GoalOrNearGoal_Query = null;

        Query<Object> nearestAnd_GoalOrNearGoal_QueryFlow =
            new Query<Object>() {
                public Iterable<Object> query() {
                    return new FilteredIterator<Object>(context.iterator(),
                        new Predicate() {
                            public boolean evaluate(Object object) {
                                if (object instanceof Area) {
                                    Area areaInTerritory = (Area) object;
                                    return (areaInTerritory.isNearGoal() ||
                                    areaInTerritory.isGoal());
                                } else {
                                    return false;
                                }
                            }
                        });

                }

                public Iterable<Object> query(Iterable<Object> other) {
                    return new FilteredIterator<Object>(query().iterator(),
                        QueryUtils.createContains(other));
                }
            };

        nearestAnd_GoalOrNearGoal_Query =
            new Query<Object>() {
                    public Iterable<Object> query() {
                        return Collections.EMPTY_LIST;
                    }

                    public Iterable<Object> query(Iterable<Object> other) {
                        final Comparator nearestAnd_GoalOrNearGoal_Comp =
                            new Comparator<Object>() {
                                public int distance(Object source, Object target) {
                                    GridPoint gs =
                                        territory.getLocation(source);
                                    GridPoint gt =
                                        territory.getLocation(target);
                                    return Math.min(Math.abs(gs.getX() -
                                            gt.getX()),
                                        Math.abs(gs.getY() - gt.getY()));
                                }

                                public int compare(Object agent1, Object agent2) {
                                    return distance(this, agent1) -
                                    distance(this, agent2);
                                }
                            };
                        final Collection nearestAnd_GoalOrNearGoal_List =
                            IteratorUtils.toList(other.iterator());
                        final Collection nearestAnd_GoalOrNearGoal_Mins =
                            new ArrayList();
                        Object minAgent =
                            Collections.min(nearestAnd_GoalOrNearGoal_List,
                                nearestAnd_GoalOrNearGoal_Comp);
                        while (minAgent != null) {
                            nearestAnd_GoalOrNearGoal_Mins.add(minAgent);
                            nearestAnd_GoalOrNearGoal_List.remove(minAgent);
                            Object nextAgent =
                                Collections.min(nearestAnd_GoalOrNearGoal_List,
                                    nearestAnd_GoalOrNearGoal_Comp);
                            if (nextAgent != null &&
                                  nearestAnd_GoalOrNearGoal_Comp.compare(
                                      minAgent, nextAgent) == 0) {
                                minAgent = nextAgent;
                            } else {
                                minAgent = null;
                            }
                        }
                        return nearestAnd_GoalOrNearGoal_Mins;
                    }
                };

        nearestAnd_GoalOrNearGoal_Query = new AndQuery<Object>(nearestAnd_GoalOrNearGoal_Query,
                nearestAnd_GoalOrNearGoal_QueryFlow);

        Iterator nearestAnd_GoalOrNearGoal_Iter =
            nearestAnd_GoalOrNearGoal_Query.query(context.getRandomObjects(
                    Area.class, context.size())).iterator();
        if (nearestAnd_GoalOrNearGoal_Iter.hasNext()) {
            final Area areaInTerritory =
                (Area) nearestAnd_GoalOrNearGoal_Iter.next();

            int[] aMoveLoc =
                territory.getLocation(areaInTerritory).toIntArray(null);
            territory.moveTo(this, aMoveLoc);

        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 8)
    public void towardMove() {
        final Context context = ContextUtils.getContext(this);

        final Grid territory = (Grid) context.getProjection("Territory");

        Query<Object> identityNearGoalCopyCopyAndIsNearestAndSpaceTowardQuery =
            null;

        Query<Object> identityNearGoalCopyCopyAndIsNearestAndSpaceTowardQueryFlow =
            new Query<Object>() {
                public Iterable<Object> query() {
                    return new FilteredIterator<Object>(context.iterator(),
                        new Predicate() {
                            public boolean evaluate(Object object) {
                                if (object instanceof Area) {
                                    Area selectNearestToward = (Area) object;
                                    return selectNearestToward.isNearGoal();
                                } else {
                                    return false;
                                }
                            }
                        });

                }

                public Iterable<Object> query(Iterable<Object> other) {
                    return new FilteredIterator<Object>(query().iterator(),
                        QueryUtils.createContains(other));
                }
            };

        identityNearGoalCopyCopyAndIsNearestAndSpaceTowardQuery =
            new Query<Object>() {
                    public Iterable<Object> query() {
                        return Collections.EMPTY_LIST;
                    }

                    public Iterable<Object> query(Iterable<Object> other) {
                        final Comparator identityNearGoalCopyCopyAndIsNearestAndSpaceTowardComp =
                            new Comparator<Object>() {
                                public int distance(Object source, Object target) {
                                    GridPoint gs =
                                        territory.getLocation(source);
                                    GridPoint gt =
                                        territory.getLocation(target);
                                    return Math.min(Math.abs(gs.getX() -
                                            gt.getX()),
                                        Math.abs(gs.getY() - gt.getY()));
                                }

                                public int compare(Object agent1, Object agent2) {
                                    return distance(this, agent1) -
                                    distance(this, agent2);
                                }
                            };
                        final Collection identityNearGoalCopyCopyAndIsNearestAndSpaceTowardList =
                            IteratorUtils.toList(other.iterator());
                        final Collection identityNearGoalCopyCopyAndIsNearestAndSpaceTowardMins =
                            new ArrayList();
                        Object minAgent =
                            Collections.min(identityNearGoalCopyCopyAndIsNearestAndSpaceTowardList,
                                identityNearGoalCopyCopyAndIsNearestAndSpaceTowardComp);
                        while (minAgent != null) {
                            identityNearGoalCopyCopyAndIsNearestAndSpaceTowardMins.add(minAgent);
                            identityNearGoalCopyCopyAndIsNearestAndSpaceTowardList.remove(minAgent);
                            Object nextAgent =
                                Collections.min(identityNearGoalCopyCopyAndIsNearestAndSpaceTowardList,
                                    identityNearGoalCopyCopyAndIsNearestAndSpaceTowardComp);
                            if (nextAgent != null &&
                                  identityNearGoalCopyCopyAndIsNearestAndSpaceTowardComp.compare(
                                      minAgent, nextAgent) == 0) {
                                minAgent = nextAgent;
                            } else {
                                minAgent = null;
                            }
                        }
                        return identityNearGoalCopyCopyAndIsNearestAndSpaceTowardMins;
                    }
                };

        identityNearGoalCopyCopyAndIsNearestAndSpaceTowardQuery = new AndQuery<Object>(identityNearGoalCopyCopyAndIsNearestAndSpaceTowardQuery,
                identityNearGoalCopyCopyAndIsNearestAndSpaceTowardQueryFlow);

        Iterator identityNearGoalCopyCopyAndIsNearestAndSpaceTowardIter =
            identityNearGoalCopyCopyAndIsNearestAndSpaceTowardQuery.query(context.getRandomObjects(
                    Area.class, context.size())).iterator();
        if (identityNearGoalCopyCopyAndIsNearestAndSpaceTowardIter.hasNext()) {
            final Area selectNearestToward =
                (Area) identityNearGoalCopyCopyAndIsNearestAndSpaceTowardIter.next();

            int[] aMoveCopyCopyLoc =
                territory.getLocation(selectNearestToward).toIntArray(null);
            territory.moveTo(this, aMoveCopyCopyLoc);

        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 19)
    public void nearestWithinMove() {
        final Context context = ContextUtils.getContext(this);

        final Grid territory = (Grid) context.getProjection("Territory");

        Query<Object> identityGoalCopyAndWithin_Vision_AndAreaWithGoalQuery =
            null;

        Query<Object> identityGoalCopyAndWithin_Vision_AndAreaWithGoalQueryFlow =
            new Query<Object>() {
                public Iterable<Object> query() {
                    return new FilteredIterator<Object>(context.iterator(),
                        new Predicate() {
                            public boolean evaluate(Object object) {
                                if (object instanceof Area) {
                                    Area areaWithGoal = (Area) object;
                                    return areaWithGoal.isGoal();
                                } else {
                                    return false;
                                }
                            }
                        });

                }

                public Iterable<Object> query(Iterable<Object> other) {
                    return new FilteredIterator<Object>(query().iterator(),
                        QueryUtils.createContains(other));
                }
            };

        identityGoalCopyAndWithin_Vision_AndAreaWithGoalQuery = new GridWithin(territory,
                this, getVision());

        identityGoalCopyAndWithin_Vision_AndAreaWithGoalQuery = new AndQuery<Object>(identityGoalCopyAndWithin_Vision_AndAreaWithGoalQuery,
                identityGoalCopyAndWithin_Vision_AndAreaWithGoalQueryFlow);

        Iterator identityGoalCopyAndWithin_Vision_AndAreaWithGoalIter =
            identityGoalCopyAndWithin_Vision_AndAreaWithGoalQuery.query(context.getRandomObjects(
                    Area.class, context.size())).iterator();
        if (identityGoalCopyAndWithin_Vision_AndAreaWithGoalIter.hasNext()) {
            final Area areaWithGoal =
                (Area) identityGoalCopyAndWithin_Vision_AndAreaWithGoalIter.next();

            int[] moveInVisionLoc =
                territory.getLocation(areaWithGoal).toIntArray(null);
            territory.moveTo(this, moveInVisionLoc);

        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 25)
    public void moveTowardOther() {
        final Context context = ContextUtils.getContext(this);

        final Grid territory = (Grid) context.getProjection("Territory");

        Query<Object> spaceNearestAndOtherPersonAndSpaceTowardCopyQuery = null;

        spaceNearestAndOtherPersonAndSpaceTowardCopyQuery =
            new Query<Object>() {
                    public Iterable<Object> query() {
                        return Collections.EMPTY_LIST;
                    }

                    public Iterable<Object> query(Iterable<Object> other) {
                        final Comparator spaceNearestAndOtherPersonAndSpaceTowardCopyComp =
                            new Comparator<Object>() {
                                public int distance(Object source, Object target) {
                                    GridPoint gs =
                                        territory.getLocation(source);
                                    GridPoint gt =
                                        territory.getLocation(target);
                                    return Math.min(Math.abs(gs.getX() -
                                            gt.getX()),
                                        Math.abs(gs.getY() - gt.getY()));
                                }

                                public int compare(Object agent1, Object agent2) {
                                    return distance(this, agent1) -
                                    distance(this, agent2);
                                }
                            };
                        final Collection spaceNearestAndOtherPersonAndSpaceTowardCopyList =
                            IteratorUtils.toList(other.iterator());
                        final Collection spaceNearestAndOtherPersonAndSpaceTowardCopyMins =
                            new ArrayList();
                        Object minAgent =
                            Collections.min(spaceNearestAndOtherPersonAndSpaceTowardCopyList,
                                spaceNearestAndOtherPersonAndSpaceTowardCopyComp);
                        while (minAgent != null) {
                            spaceNearestAndOtherPersonAndSpaceTowardCopyMins.add(minAgent);
                            spaceNearestAndOtherPersonAndSpaceTowardCopyList.remove(minAgent);
                            Object nextAgent =
                                Collections.min(spaceNearestAndOtherPersonAndSpaceTowardCopyList,
                                    spaceNearestAndOtherPersonAndSpaceTowardCopyComp);
                            if (nextAgent != null &&
                                  spaceNearestAndOtherPersonAndSpaceTowardCopyComp.compare(
                                      minAgent, nextAgent) == 0) {
                                minAgent = nextAgent;
                            } else {
                                minAgent = null;
                            }
                        }
                        return spaceNearestAndOtherPersonAndSpaceTowardCopyMins;
                    }
                };

        Query<Object> spaceNearestAndOtherPersonAndSpaceTowardCopyQueryAgentClass =
            new Query<Object>() {
                public Iterable<Object> query() {
                    return new FilteredIterator<Object>(context.iterator(),
                        new Predicate() {
                            public boolean evaluate(Object object) {
                                return (object instanceof ActPerson1);

                            }
                        });

                }

                public Iterable<Object> query(Iterable<Object> other) {
                    return new FilteredIterator<Object>(query().iterator(),
                        QueryUtils.createContains(other));
                }
            };

        spaceNearestAndOtherPersonAndSpaceTowardCopyQuery = new AndQuery<Object>(spaceNearestAndOtherPersonAndSpaceTowardCopyQuery,
                spaceNearestAndOtherPersonAndSpaceTowardCopyQueryAgentClass);

        Iterator spaceNearestAndOtherPersonAndSpaceTowardCopyIter =
            spaceNearestAndOtherPersonAndSpaceTowardCopyQuery.query(context.getRandomObjects(
                    ActPerson1.class, context.size())).iterator();
        if (spaceNearestAndOtherPersonAndSpaceTowardCopyIter.hasNext()) {
            final ActPerson1 otherPerson =
                (ActPerson1) spaceNearestAndOtherPersonAndSpaceTowardCopyIter.next();

            int[] movetoPerson1inTerritoryLoc =
                territory.getLocation(otherPerson).toIntArray(null);
            territory.moveTo(this, movetoPerson1inTerritoryLoc);

        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 31)
    public void moveToNeighbor() {
        final Context context = ContextUtils.getContext(this);

        final Grid territory = (Grid) context.getProjection("Territory");

        Query<Object> spaceNeighborQuery = null;

        spaceNeighborQuery = new GridWithin(territory, this, 1);

        Query<Object> spaceNeighborQueryAgentClass =
            new Query<Object>() {
                public Iterable<Object> query() {
                    return new FilteredIterator<Object>(context.iterator(),
                        new Predicate() {
                            public boolean evaluate(Object object) {
                                return (object instanceof Area);

                            }
                        });

                }

                public Iterable<Object> query(Iterable<Object> other) {
                    return new FilteredIterator<Object>(query().iterator(),
                        QueryUtils.createContains(other));
                }
            };

        spaceNeighborQuery = new AndQuery<Object>(spaceNeighborQuery,
                spaceNeighborQueryAgentClass);

        Iterator spaceNeighborIter =
            spaceNeighborQuery.query(context.getRandomObjects(Area.class,
                    context.size())).iterator();
        if (spaceNeighborIter.hasNext()) {
            final Area neighboringSpace = (Area) spaceNeighborIter.next();

            int[] movetoPerson1inTerritoryCopyLoc =
                territory.getLocation(neighboringSpace).toIntArray(null);
            territory.moveTo(this, movetoPerson1inTerritoryCopyLoc);

        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 38)
    public void moveTwice() {
        final Context context = ContextUtils.getContext(this);

        final Grid territory = (Grid) context.getProjection("Territory");

        if (isMovingTowardGoal()) {
            Query<Object> identityGoalAndIsNearestCopyCopyCopyQuery = null;

            Query<Object> identityGoalAndIsNearestCopyCopyCopyQueryFlow =
                new Query<Object>() {
                    public Iterable<Object> query() {
                        return new FilteredIterator<Object>(context.iterator(),
                            new Predicate() {
                                public boolean evaluate(Object object) {
                                    if (object instanceof Area) {
                                        Area goalinArea2 = (Area) object;
                                        return goalinArea2.isGoal();
                                    } else {
                                        return false;
                                    }
                                }
                            });

                    }

                    public Iterable<Object> query(Iterable<Object> other) {
                        return new FilteredIterator<Object>(query().iterator(),
                            QueryUtils.createContains(other));
                    }
                };

            identityGoalAndIsNearestCopyCopyCopyQuery =
                new Query<Object>() {
                        public Iterable<Object> query() {
                            return Collections.EMPTY_LIST;
                        }

                        public Iterable<Object> query(Iterable<Object> other) {
                            final Comparator identityGoalAndIsNearestCopyCopyCopyComp =
                                new Comparator<Object>() {
                                    public int distance(Object source,
                                        Object target) {
                                        GridPoint gs =
                                            territory.getLocation(source);
                                        GridPoint gt =
                                            territory.getLocation(target);
                                        return Math.min(Math.abs(gs.getX() -
                                                gt.getX()),
                                            Math.abs(gs.getY() - gt.getY()));
                                    }

                                    public int compare(Object agent1,
                                        Object agent2) {
                                        return distance(this, agent1) -
                                        distance(this, agent2);
                                    }
                                };
                            final Collection identityGoalAndIsNearestCopyCopyCopyList =
                                IteratorUtils.toList(other.iterator());
                            final Collection identityGoalAndIsNearestCopyCopyCopyMins =
                                new ArrayList();
                            Object minAgent =
                                Collections.min(identityGoalAndIsNearestCopyCopyCopyList,
                                    identityGoalAndIsNearestCopyCopyCopyComp);
                            while (minAgent != null) {
                                identityGoalAndIsNearestCopyCopyCopyMins.add(minAgent);
                                identityGoalAndIsNearestCopyCopyCopyList.remove(minAgent);
                                Object nextAgent =
                                    Collections.min(identityGoalAndIsNearestCopyCopyCopyList,
                                        identityGoalAndIsNearestCopyCopyCopyComp);
                                if (nextAgent != null &&
                                      identityGoalAndIsNearestCopyCopyCopyComp.compare(
                                          minAgent, nextAgent) == 0) {
                                    minAgent = nextAgent;
                                } else {
                                    minAgent = null;
                                }
                            }
                            return identityGoalAndIsNearestCopyCopyCopyMins;
                        }
                    };

            identityGoalAndIsNearestCopyCopyCopyQuery = new AndQuery<Object>(identityGoalAndIsNearestCopyCopyCopyQuery,
                    identityGoalAndIsNearestCopyCopyCopyQueryFlow);

            Iterator identityGoalAndIsNearestCopyCopyCopyIter =
                identityGoalAndIsNearestCopyCopyCopyQuery.query(context.getRandomObjects(
                        Area.class, context.size())).iterator();
            if (identityGoalAndIsNearestCopyCopyCopyIter.hasNext()) {
                final Area goalinArea2 =
                    (Area) identityGoalAndIsNearestCopyCopyCopyIter.next();

                Query<Object> isIdentityNearGoalAndIsNearestCopyCopyQuery =
                    null;

                Query<Object> isIdentityNearGoalAndIsNearestCopyCopyQueryFlow =
                    new Query<Object>() {
                        public Iterable<Object> query() {
                            return new FilteredIterator<Object>(context.iterator(),
                                new Predicate() {
                                    public boolean evaluate(Object object) {
                                        if (object instanceof Area) {
                                            Area closestNearGoal =
                                                (Area) object;
                                            return closestNearGoal.isNearGoal();
                                        } else {
                                            return false;
                                        }
                                    }
                                });

                        }

                        public Iterable<Object> query(Iterable<Object> other) {
                            return new FilteredIterator<Object>(query()
                                                                    .iterator(),
                                QueryUtils.createContains(other));
                        }
                    };

                isIdentityNearGoalAndIsNearestCopyCopyQuery =
                    new Query<Object>() {
                            public Iterable<Object> query() {
                                return Collections.EMPTY_LIST;
                            }

                            public Iterable<Object> query(
                                Iterable<Object> other) {
                                final Comparator isIdentityNearGoalAndIsNearestCopyCopyComp =
                                    new Comparator<Object>() {
                                        public int distance(Object source,
                                            Object target) {
                                            GridPoint gs =
                                                territory.getLocation(source);
                                            GridPoint gt =
                                                territory.getLocation(target);
                                            return Math.min(Math.abs(gs.getX() -
                                                    gt.getX()),
                                                Math.abs(gs.getY() - gt.getY()));
                                        }

                                        public int compare(Object agent1,
                                            Object agent2) {
                                            return distance(goalinArea2, agent1) -
                                            distance(goalinArea2, agent2);
                                        }
                                    };
                                final Collection isIdentityNearGoalAndIsNearestCopyCopyList =
                                    IteratorUtils.toList(other.iterator());
                                final Collection isIdentityNearGoalAndIsNearestCopyCopyMins =
                                    new ArrayList();
                                Object minAgent =
                                    Collections.min(isIdentityNearGoalAndIsNearestCopyCopyList,
                                        isIdentityNearGoalAndIsNearestCopyCopyComp);
                                while (minAgent != null) {
                                    isIdentityNearGoalAndIsNearestCopyCopyMins.add(minAgent);
                                    isIdentityNearGoalAndIsNearestCopyCopyList.remove(minAgent);
                                    Object nextAgent =
                                        Collections.min(isIdentityNearGoalAndIsNearestCopyCopyList,
                                            isIdentityNearGoalAndIsNearestCopyCopyComp);
                                    if (nextAgent != null &&
                                          isIdentityNearGoalAndIsNearestCopyCopyComp.compare(
                                              minAgent, nextAgent) == 0) {
                                        minAgent = nextAgent;
                                    } else {
                                        minAgent = null;
                                    }
                                }
                                return isIdentityNearGoalAndIsNearestCopyCopyMins;
                            }
                        };

                isIdentityNearGoalAndIsNearestCopyCopyQuery = new AndQuery<Object>(isIdentityNearGoalAndIsNearestCopyCopyQuery,
                        isIdentityNearGoalAndIsNearestCopyCopyQueryFlow);

                Iterator isIdentityNearGoalAndIsNearestCopyCopyIter =
                    isIdentityNearGoalAndIsNearestCopyCopyQuery.query(context.getRandomObjects(
                            Area.class, context.size())).iterator();
                if (isIdentityNearGoalAndIsNearestCopyCopyIter.hasNext()) {
                    final Area closestNearGoal =
                        (Area) isIdentityNearGoalAndIsNearestCopyCopyIter.next();

                    int[] movetoAreainTerritoryLoc =
                        territory.getLocation(closestNearGoal).toIntArray(null);
                    territory.moveTo(this, movetoAreainTerritoryLoc);

                }
            }
        }
    }

    /**
     * Gets the Vision property for Act Person 1.
     * @return
     */
    @Parameter(displayName = "Vision", usageName = "vision", defaultValue = "20")
    public int getVision() {
        return vision;
    }

    /**
     * Sets the Vision property for Act Person 1.
     *
     * @param _vision the new Vision value
     */
    public void setVision(int _vision) {
        vision = _vision;

    }

    /**
     * Gets the Moving Toward Goal property for Act Person 1.
     * @return
     */
    @Parameter(displayName = "Moving Toward Goal", usageName = "movingTowardGoal", defaultValue = "true")
    public boolean isMovingTowardGoal() {
        return movingTowardGoal;
    }

    /**
     * Sets the Moving Toward Goal property for Act Person 1.
     *
     * @param _movingTowardGoal the new Moving Toward Goal value
     */
    public void setMovingTowardGoal(boolean _movingTowardGoal) {
        movingTowardGoal = _movingTowardGoal;

    }

    /**
     * Gets the Act Model property for Named.
     * @return Most recent version.
     */
    public static ActModel getActModel() {
        return model;
    }

    /**
     * Sets the Act Model property for Named.
     * Most recent version.
     * @param _actModel the new Act Model value
     */
    public static void setActModel(ActModel _actModel) {
        model = _actModel;

    }

    public String getUID() {
        return uniqueID;
    }

    public String toString() {
        return "Act Person 1 " + uniqueID;
    }

    public void createUniqueID() {
        uniqueID = RandomStringUtils.randomAlphanumeric(5);
    }

    /**
     * Clones the agent, ensuring that a unique id is assigned.
     */
    public Object clone() {
        try {
            ActPerson1 clone = (ActPerson1) super.clone();
            clone.createUniqueID();
            return clone;
        } catch (Exception e) {
            throw new RuntimeException("Unexpected cloning exception: " + e);
        }
    }
}
