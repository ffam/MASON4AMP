package org.metaabm.gen.test;

import org.apache.commons.collections15.IteratorUtils;
import org.apache.commons.collections15.Predicate;
import org.apache.commons.lang.RandomStringUtils;

import java.lang.Iterable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import junit.framework.TestCase;

import repast.context.Context;

import repast.engine.schedule.ScheduledMethod;

import repast.parameter.Parameter;

import repast.query.AndQuery;
import repast.query.Query;
import repast.query.QueryUtils;
import repast.query.space.graph.NetPathWithin;

import repast.random.RandomHelper;

import repast.space.graph.Network;
import repast.space.graph.RepastEdge;
import repast.space.grid.Grid;
import repast.space.grid.GridPoint;

import repast.util.ContextUtils;
import repast.util.collections.FilteredIterator;

/**
 * Act Person 2 Java Implementation.
 *
 *
 * Generated by metaabm system: Sep 18, 2007 5:24:56 PM EDT
 */
public class ActPerson2 extends TestCase {

    /**
     *
     */
    private static ActModel model;

    /**
     *
     */
    private int vision;

    /**
     *
     */
    private boolean movingTowardGoal = true;
    private String uniqueID;

    /**
     * Constructs a new Act Person 2.
     */
    public ActPerson2() {
        createUniqueID();
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 0)
    public void moveTwice() {
        final Context context = ContextUtils.getContext(this);

        final Grid territory = (Grid) context.getProjection("Territory");

        if (isMovingTowardGoal()) {
            Query<Object> identityGoalQuery =
                new Query<Object>() {
                    public Iterable<Object> query() {
                        return new FilteredIterator<Object>(context.iterator(),
                            new Predicate() {
                                public boolean evaluate(Object area) {
                                    if (area instanceof Area) {
                                        return ((Area) area).isGoal();
                                    } else {
                                        return false;
                                    }
                                }
                            });

                    }

                    public Iterable<Object> query(Iterable<Object> other) {
                        return new FilteredIterator<Object>(query().iterator(),
                            QueryUtils.createContains(other));

                    }
                };

            Query<Object> isNearestCopyCopyCopyQuery =
                new Query<Object>() {
                    public Iterable<Object> query() {
                        return Collections.EMPTY_LIST;

                    }

                    public Iterable<Object> query(Iterable<Object> other) {
                        final Comparator isNearestCopyCopyCopyComp =
                            new Comparator<Object>() {
                                public int distance(Object source, Object target) {
                                    GridPoint gs =
                                        territory.getLocation(source);
                                    GridPoint gt =
                                        territory.getLocation(target);
                                    return Math.min(Math.abs(gs.getX() -
                                            gt.getX()),
                                        Math.abs(gs.getY() - gt.getY()));
                                }

                                public int compare(Object agent1, Object agent2) {
                                    return distance(this, agent1) -
                                    distance(this, agent2);
                                }
                            };
                        final Collection isNearestCopyCopyCopyList =
                            IteratorUtils.toList(other.iterator());
                        final Collection isNearestCopyCopyCopyMins =
                            new ArrayList();
                        Object minAgent =
                            Collections.min(isNearestCopyCopyCopyList,
                                isNearestCopyCopyCopyComp);
                        int minValue = Integer.MAX_VALUE;
                        while (minAgent != null) {
                            isNearestCopyCopyCopyMins.add(minAgent);
                            isNearestCopyCopyCopyList.remove(minAgent);
                            Object nextAgent =
                                Collections.min(isNearestCopyCopyCopyList,
                                    isNearestCopyCopyCopyComp);
                            if (nextAgent != null &&
                                  isNearestCopyCopyCopyComp.compare(minAgent,
                                      nextAgent) == 0) {
                                minAgent = nextAgent;
                            } else {
                                minAgent = null;
                            }
                        }
                        return isNearestCopyCopyCopyMins;

                    }
                };

            Query<Object> identityGoalAndIsNearestCopyCopyCopyQuery =
                new AndQuery<Object>(identityGoalQuery,
                    isNearestCopyCopyCopyQuery);

            Iterator identityGoalAndIsNearestCopyCopyCopyIter =
                IteratorUtils.filteredIterator(identityGoalAndIsNearestCopyCopyCopyQuery.query()
                                                                                        .iterator(),
                    new Predicate() {
                        public boolean evaluate(Object object) {
                            return object instanceof Area;
                        }
                    });
            List identityGoalAndIsNearestCopyCopyCopyAgents =
                IteratorUtils.toList(identityGoalAndIsNearestCopyCopyCopyIter);
            if (identityGoalAndIsNearestCopyCopyCopyAgents.size() > 0) {
                final Area goalinArea2 =
                    (Area) identityGoalAndIsNearestCopyCopyCopyAgents.get(RandomHelper.nextIntFromTo(
                            0,
                            identityGoalAndIsNearestCopyCopyCopyAgents.size() -
                            1));

                Query<Object> isIdentityNearGoalQuery =
                    new Query<Object>() {
                        public Iterable<Object> query() {
                            return new FilteredIterator<Object>(context.iterator(),
                                new Predicate() {
                                    public boolean evaluate(Object area) {
                                        if (area instanceof Area) {
                                            return ((Area) area).isNearGoal();
                                        } else {
                                            return false;
                                        }
                                    }
                                });

                        }

                        public Iterable<Object> query(Iterable<Object> other) {
                            return new FilteredIterator<Object>(query()
                                                                    .iterator(),
                                QueryUtils.createContains(other));

                        }
                    };

                Query<Object> spaceNearestCopyQuery =
                    new Query<Object>() {
                        public Iterable<Object> query() {
                            return Collections.EMPTY_LIST;

                        }

                        public Iterable<Object> query(Iterable<Object> other) {
                            final Comparator spaceNearestCopyComp =
                                new Comparator<Object>() {
                                    public int distance(Object source,
                                        Object target) {
                                        GridPoint gs =
                                            territory.getLocation(source);
                                        GridPoint gt =
                                            territory.getLocation(target);
                                        return Math.min(Math.abs(gs.getX() -
                                                gt.getX()),
                                            Math.abs(gs.getY() - gt.getY()));
                                    }

                                    public int compare(Object agent1,
                                        Object agent2) {
                                        return distance(goalinArea2, agent1) -
                                        distance(goalinArea2, agent2);
                                    }
                                };
                            final Collection spaceNearestCopyList =
                                IteratorUtils.toList(other.iterator());
                            final Collection spaceNearestCopyMins =
                                new ArrayList();
                            Object minAgent =
                                Collections.min(spaceNearestCopyList,
                                    spaceNearestCopyComp);
                            int minValue = Integer.MAX_VALUE;
                            while (minAgent != null) {
                                spaceNearestCopyMins.add(minAgent);
                                spaceNearestCopyList.remove(minAgent);
                                Object nextAgent =
                                    Collections.min(spaceNearestCopyList,
                                        spaceNearestCopyComp);
                                if (nextAgent != null &&
                                      spaceNearestCopyComp.compare(minAgent,
                                          nextAgent) == 0) {
                                    minAgent = nextAgent;
                                } else {
                                    minAgent = null;
                                }
                            }
                            return spaceNearestCopyMins;

                        }
                    };

                Query<Object> isIdentityNearGoalAndIsNearestCopyCopyQuery =
                    new AndQuery<Object>(isIdentityNearGoalQuery,
                        spaceNearestCopyQuery);

                Iterator isIdentityNearGoalAndIsNearestCopyCopyIter =
                    IteratorUtils.filteredIterator(isIdentityNearGoalAndIsNearestCopyCopyQuery.query()
                                                                                              .iterator(),
                        new Predicate() {
                            public boolean evaluate(Object object) {
                                return object instanceof Area;
                            }
                        });
                List isIdentityNearGoalAndIsNearestCopyCopyAgents =
                    IteratorUtils.toList(isIdentityNearGoalAndIsNearestCopyCopyIter);
                if (isIdentityNearGoalAndIsNearestCopyCopyAgents.size() > 0) {
                    final Area closestNearGoal =
                        (Area) isIdentityNearGoalAndIsNearestCopyCopyAgents.get(RandomHelper.nextIntFromTo(
                                0,
                                isIdentityNearGoalAndIsNearestCopyCopyAgents.size() -
                                1));

                    int[] movetoAreainTerritoryLoc =
                        territory.getLocation(closestNearGoal).toIntArray(null);
                    territory.moveTo(goalinArea2, movetoAreainTerritoryLoc);

                }
            }
        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 8)
    public void simpleNetworkMoveToAgent() {
        final Context context = ContextUtils.getContext(this);

        final Network testNetwork =
            (Network) context.getProjection("Test Network");

        final Grid territory = (Grid) context.getProjection("Territory");

        Query<Object> spaceNeighborQuery =
            new NetPathWithin(testNetwork, this, 1);

        Iterator spaceNeighborIter =
            IteratorUtils.filteredIterator(spaceNeighborQuery.query().iterator(),
                new Predicate() {
                    public boolean evaluate(Object object) {
                        return object instanceof ActPerson2;
                    }
                });
        List spaceNeighborAgents = IteratorUtils.toList(spaceNeighborIter);
        if (spaceNeighborAgents.size() > 0) {
            final ActPerson2 person2 =
                (ActPerson2) spaceNeighborAgents.get(RandomHelper.nextIntFromTo(
                        0, spaceNeighborAgents.size() - 1));

            Iterable<RepastEdge> outEdges = testNetwork.getOutEdges(this);
            for (RepastEdge edge : outEdges) {
                testNetwork.removeEdge(edge);
            }
            Iterable<RepastEdge> inEdges = testNetwork.getInEdges(this);
            for (RepastEdge edge : inEdges) {
                testNetwork.removeEdge(edge);
            }
            Iterable<RepastEdge> outNewEdges = testNetwork.getOutEdges(person2);
            for (RepastEdge edge : outNewEdges) {
                testNetwork.addEdge(edge);
            }
            Iterable<RepastEdge> inNewEdges = testNetwork.getInEdges(person2);
            for (RepastEdge edge : inNewEdges) {
                testNetwork.addEdge(edge);
            }
        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 12)
    public void simpleNetworkMoveFromCell() {
        final Context context = ContextUtils.getContext(this);

        final Network testNetwork =
            (Network) context.getProjection("Test Network");

        final Grid territory = (Grid) context.getProjection("Territory");

        Query<Object> spaceNeighborCopyQuery =
            new NetPathWithin(testNetwork, this, 1);

        Iterator spaceNeighborCopyIter =
            IteratorUtils.filteredIterator(spaceNeighborCopyQuery.query()
                                                                 .iterator(),
                new Predicate() {
                    public boolean evaluate(Object object) {
                        return object instanceof Area;
                    }
                });
        List spaceNeighborCopyAgents =
            IteratorUtils.toList(spaceNeighborCopyIter);
        if (spaceNeighborCopyAgents.size() > 0) {
            final Area person2Copy =
                (Area) spaceNeighborCopyAgents.get(RandomHelper.nextIntFromTo(
                        0, spaceNeighborCopyAgents.size() - 1));

            Iterable<RepastEdge> outEdges = testNetwork.getOutEdges(this);
            for (RepastEdge edge : outEdges) {
                testNetwork.removeEdge(edge);
            }
            Iterable<RepastEdge> inEdges = testNetwork.getInEdges(this);
            for (RepastEdge edge : inEdges) {
                testNetwork.removeEdge(edge);
            }
            Iterable<RepastEdge> outNewEdges =
                testNetwork.getOutEdges(person2Copy);
            for (RepastEdge edge : outNewEdges) {
                testNetwork.addEdge(edge);
            }
            Iterable<RepastEdge> inNewEdges =
                testNetwork.getInEdges(person2Copy);
            for (RepastEdge edge : inNewEdges) {
                testNetwork.addEdge(edge);
            }
        }
    }

    /**
     * .
     */
    @ScheduledMethod(start = 1, interval = 1, priority = 16)
    public void simpleNetworkMoveTowardAgent() {
        final Context context = ContextUtils.getContext(this);

        final Network testNetwork =
            (Network) context.getProjection("Test Network");

        final Grid territory = (Grid) context.getProjection("Territory");

        Query<Object> spaceNearestQuery =
            new Query<Object>() {
                public Iterable<Object> query() {
                    return Collections.EMPTY_LIST;

                }

                public Iterable<Object> query(Iterable<Object> other) {

                    //Nearest not yet supported for projection type: Test Network
                    return Collections.EMPTY_LIST;

                }
            };

        Query<Object> towardPersonQuery =
            new NetPathWithin(testNetwork, this, 1);

        Query<Object> spaceNearestAndTowardPersonQuery =
            new AndQuery<Object>(spaceNearestQuery, towardPersonQuery);

        Iterator spaceNearestAndTowardPersonIter =
            IteratorUtils.filteredIterator(spaceNearestAndTowardPersonQuery.query()
                                                                           .iterator(),
                new Predicate() {
                    public boolean evaluate(Object object) {
                        return object instanceof ActPerson2;
                    }
                });
        List spaceNearestAndTowardPersonAgents =
            IteratorUtils.toList(spaceNearestAndTowardPersonIter);
        if (spaceNearestAndTowardPersonAgents.size() > 0) {
            final ActPerson2 person2CopyCopy =
                (ActPerson2) spaceNearestAndTowardPersonAgents.get(RandomHelper.nextIntFromTo(
                        0, spaceNearestAndTowardPersonAgents.size() - 1));

            Iterable<RepastEdge> outEdges = testNetwork.getOutEdges(this);
            for (RepastEdge edge : outEdges) {
                testNetwork.removeEdge(edge);
            }
            Iterable<RepastEdge> inEdges = testNetwork.getInEdges(this);
            for (RepastEdge edge : inEdges) {
                testNetwork.removeEdge(edge);
            }
            Iterable<RepastEdge> outNewEdges =
                testNetwork.getOutEdges(person2CopyCopy);
            for (RepastEdge edge : outNewEdges) {
                testNetwork.addEdge(edge);
            }
            Iterable<RepastEdge> inNewEdges =
                testNetwork.getInEdges(person2CopyCopy);
            for (RepastEdge edge : inNewEdges) {
                testNetwork.addEdge(edge);
            }
        }
    }

    /**
     * Gets the Vision property for Act Person 2.
     * @return
     */
    @Parameter(displayName = "Vision", usageName = "vision", defaultValue = "")
    public int getVision() {
        return vision;
    }

    /**
     * Sets the Vision property for Act Person 2.
     *
     * @param _vision the new Vision value
     */
    public void setVision(int _vision) {
        vision = _vision;

    }

    /**
     * Gets the Moving Toward Goal property for Act Person 2.
     * @return
     */
    @Parameter(displayName = "Moving Toward Goal", usageName = "movingTowardGoal", defaultValue = "true")
    public boolean isMovingTowardGoal() {
        return movingTowardGoal;
    }

    /**
     * Sets the Moving Toward Goal property for Act Person 2.
     *
     * @param _movingTowardGoal the new Moving Toward Goal value
     */
    public void setMovingTowardGoal(boolean _movingTowardGoal) {
        movingTowardGoal = _movingTowardGoal;

    }

    /**
     * Gets the Act Model property for Named.
     * @return
     */
    public static ActModel getActModel() {
        return model;
    }

    /**
     * Sets the Act Model property for Named.
     *
     * @param _actModel the new Act Model value
     */
    public static void setActModel(ActModel _actModel) {
        model = _actModel;

    }

    public String getUID() {
        return uniqueID;
    }

    public String toString() {
        return "Act Person 2 " + uniqueID;
    }

    public void createUniqueID() {
        uniqueID = RandomStringUtils.randomAlphanumeric(5);
    }

    /**
     * Clones the agent, ensuring that a unique id is assigned.
     */
    public Object clone() {
        try {
            ActPerson2 clone = (ActPerson2) super.clone();
            clone.createUniqueID();
            return clone;
        } catch (Exception e) {
            throw new RuntimeException("Unexpected cloning exception: " + e);
        }
    }
}
